# -*- coding: utf-8 -*-
"""2D exp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TxRdB6cMT78d8USQyl66yv3yhrSVIEpC
"""
from surface import plot_3Dsurface
import torch                                   # библиотека для работы с нейронныит сетями. Здесь нужна для вычислений с производными
import numpy as np                             # математическая библиотека Python
boxsize = 1.0*np.ones(2)                       # размер расчетной области
Nx = 11*torch.ones(2)                          # количество узлов
N = 1000                                        # количество частиц

pos = np.multiply(np.random.rand(N,2),boxsize) #  массив координат частиц
pos = torch.from_numpy(pos)                    #  преобразоввание в формат библиотеки PyTorch
pos.requires_grad = True                       #  флаг, разрешающий взятие производных по массиву pos

def denst(Pos,Nx,boxsize,n0):                      #  функция, вычисляющая плотность по массиву частиц
    dx = boxsize/Nx
    n= torch.zeros(Nx)
    for pos in Pos:
        j = torch.floor(pos / dx).int()
        #print('pos,j ',pos,j)
        jp1 = j + 1
        weight_j=(jp1 * dx - pos) / dx            # ((j+1)*dx - x)/dx = j+1 - x/dx = (j+1 - j - d) = 1-d
        weight_jp1 = (pos - j * dx) / dx          #  (x - j*dx)/dx = x/dx - j = j+d - j = d
        jp1 = torch.remainder(jp1, Nx)
        n[j] += weight_j
        n[jp1] += weight_jp1
    n *= n0 * boxsize / N / dx
    return n

def denst2D(Pos,Nx,boxsize,n0,xx,yy,w):                      #  функция, вычисляющая плотность по массиву частиц
    if(torch.max(Pos[:,0]) > boxsize[0] or torch.max(Pos[:,1]) > boxsize[1]):
        Pos = torch.remainder(Pos,boxsize)

    dx = xx[1] - xx[0]
    dy = yy[1] - yy[0]
    dx = torch.tensor([dx,dy])
    n = torch.zeros(Nx.int().tolist())
    for pos in Pos:
        j = torch.floor(torch.divide(pos, dx)).long()
        #print('pos,j ',pos,j)
        jp1 = j + 1

        weight_j=torch.divide(torch.multiply(jp1,dx) - pos,dx)          #
        weight_jp1 = torch.divide((pos - torch.multiply(j,dx)) , dx)
        jp1 = torch.remainder(jp1, Nx)
        jp1 = jp1.long()
        n[j[0]][j[1]]     += weight_j[0] * weight_j[1]      # i,j       (1-dx)*(1-dy)
        n[j[0]][jp1[1]]   += weight_j[0] * weight_jp1[1]    # i,j+1     (1-dx)*dy
        n[jp1[0]][j[1]]   += weight_jp1[0] * weight_j[1]    # i+1,j     dx*(1-dy)
        n[jp1[0]][jp1[1]] += weight_jp1[0] * weight_jp1[1]  # i+1,j+1   dx*dy


   # n *= n0 * boxsize[0]*boxsize[1] / N / dx[0]/dx[1]
    n *= w
    return n

xx = np.linspace(0, boxsize[0], Nx[0].int())
yy = np.linspace(0, boxsize[1], Nx[1].int())

# n = denst2D(pos,Nx,torch.from_numpy(boxsize),1.0,xx,yy)                     # пробный запуск
# print(n)

# xx = torch.linspace(0,boxsize,Nx)

import sys


X,Y = np.meshgrid(xx,yy)
n0 = np.exp(0.5*X)

from PIC_aux import get_particles
# n0 =
parts = get_particles(torch.from_numpy(n0),1,xx,yy)
n = denst2D(parts,Nx,torch.from_numpy(boxsize),1.0,xx,yy)


plot_3Dsurface(xx,yy,n0,'X','Y','sample function')

import matplotlib.pyplot as plt
# fig = plt.figure()
# plt.legend()
# n0 = torch.exp(xx) # профиль плоности, который нужно воспроизвести с помощью частиц. Обязательно в виде массива библиотеки PyTorch
# plt.plot(xx.numpy(),n0.detach().numpy(),color='green')
n0 = torch.from_numpy(n0)
optimizer = torch.optim.Adam([pos],lr=0.01)
lf = 1e6*torch.ones(1)
i = 0

while lf.item() > 1e-2:
    optimizer.zero_grad()
    n = denst2D(pos,Nx,torch.from_numpy(boxsize),1.0,xx,yy)
    #n0 = torch.ones_like(n)
    #plt.plot(xx.numpy(),n.detach().numpy(),color='red',label='iteration '+ str(i))
    # n0 = torch.exp(xx) # torch.ones_like(n)
    lf = torch.max(torch.abs(torch.subtract(n,n0)))  # функция потерь: разница между текущим и желаемым профилем плотности: max|n-n_0|
    print(i,lf.item())
    lf.backward()          # вычисление производных функции потерь по всему, от чего она зависит, в данном случае только производная по массиву pos
    optimizer.step()       # изменение независимых переменных (массива pos)
    i = i+1
plot_3Dsurface(xx,yy,n.detach().numpy(),'X','Y','PIC density')
#plt.scatter(xx.numpy(),n.detach().numpy(),color='blue',marker='o')

def F(tau):
    if(torch.abs(tau) < 1.0):
      t = torch.exp(1-tau**2)
    else:
      t = 0
    return t
xx = torch.linspace(0,boxsize,Nx)

yy = [F(x) for x in xx]
n0 = torch.tensor(yy)
print(n0)

import matplotlib.pyplot as plt
plt.plot(xx.numpy(),n0.numpy())